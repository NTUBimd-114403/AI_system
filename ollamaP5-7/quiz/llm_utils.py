import ollama
import json
import random
import hashlib
from datetime import datetime
from django.utils.timezone import make_aware
from .models import ReadingPassage, Question

DEFAULT_MODEL = 'llama3:8b'

# ---------- 工具：標題擷取 ----------
def extract_title_from_content(content: str, max_words: int = 6) -> str:
    content = content.strip().replace('\n', ' ')
    words = content.split()
    title = ' '.join(words[:max_words])
    return title + "..." if len(words) > max_words else title

# ---------- 工具：產生唯一 hash ----------
def compute_content_hash(content: str) -> str:
    content = content.strip().replace('\n', '')
    return hashlib.sha256(content.encode('utf-8')).hexdigest()

# ---------- 共用儲存 ----------
def save_toeic_data(data):
    part = data.get('part')
    content = data.get('content_with_blanks', '') or data.get('content', '')

    # Part5 不檢查內容是否為空
    if part != 'Part5':
        if not content.strip():
            print("❌ 內容為空，略過儲存")
            return None

    # 檢查題目是否存在
    if not data.get('questions') or len(data['questions']) == 0:
        print("❌ 題目為空，略過儲存")
        return None

    # 若文章沒內容，用題目json當hash來源，避免重複
    hash_source = content if content.strip() else json.dumps(data['questions'], ensure_ascii=False)
    content_hash = compute_content_hash(hash_source)

    # Part5 不檢查重複，其他 Part 有檢查
    if part != 'Part5':
        if ReadingPassage.objects.filter(content_hash=content_hash).exists():
            print("⚠️ 重複內容，已略過儲存。")
            return None

    # 取得今日零點時間(aware)
    today = datetime.now().date()
    start_datetime = make_aware(datetime.combine(today, datetime.min.time()))
    end_datetime = make_aware(datetime.combine(today, datetime.max.time()))

    # 當天已有幾筆同Part資料
    count_today = ReadingPassage.objects.filter(
        part=part,
        created_at__range=(start_datetime, end_datetime)
    ).count()

    title = f"{today.isoformat()}-{count_today+1}"

    # Part7 還是用 LLM 回傳標題或擷取
    if part == 'Part7':
        title = data.get('title') or extract_title_from_content(content)

    passage = ReadingPassage.objects.create(
        part=part,
        title=title,
        content_with_blanks=content,
        word_count=data.get('word_count', 0),
        reading_level=data.get('reading_level', 'Intermediate'),
        topic=data.get('topic', 'General'),
        source=data.get('source', 'Generated by LLM'),
        content_hash=content_hash
    )

    for idx, q in enumerate(data.get('questions', []), start=1):
        Question.objects.create(
            passage=passage,
            blank_number=q.get('blank_number', idx),
            question_text=q.get('question_text', '').strip(),
            option_a=q['options'].get('A', ''),
            option_b=q['options'].get('B', ''),
            option_c=q['options'].get('C', ''),
            option_d=q['options'].get('D', ''),
            correct_answer=q['correct_answer'],
            explanation=q.get('explanation', '')
        )
    return passage

# ---------- Part 5 ----------
def generate_part5_questions(debug: bool = False, max_retries: int = 3) -> bool:
    prompt = """
You are a TOEIC test writer. Please generate 5 TOEIC Part 5 questions (Incomplete Sentences).
Make sure to include exactly 5 questions.

Use the following JSON format only:

{
  "part": "Part5",
  "title": "Part 5 - Incomplete Sentences",
  "word_count": 150,
  "reading_level": "Intermediate",
  "topic": "Business English",
  "source": "Generated by LLM",
  "questions": [
    {
      "question_text": "The manager ______ the schedule.",
      "options": { "A": "adjust", "B": "adjusted", "C": "adjusting", "D": "adjusts" },
      "correct_answer": "B",
      "explanation": "Past tense is needed."
    }
  ]
}
Only return the JSON.
"""
    for retry_index in range(max_retries):
        response = ollama.chat(model=DEFAULT_MODEL, messages=[{"role": "user", "content": prompt}])
        content = response['message']['content']

        if debug:
            print(f"🔹 Part 5 第{retry_index+1}次嘗試生成內容：\n", content)

        try:
            data = json.loads(content)
            if len(data.get("questions", [])) == 5:
                saved = save_toeic_data(data)
                if saved:
                    return True
        except json.JSONDecodeError as e:
            print("❌ JSON decode failed:", e)
    return False

# ---------- Part 6 ----------
def generate_part6_questions(debug: bool = False, max_retries: int = 3) -> bool:
    prompt = """
You are a TOEIC test writer. Please generate a TOEIC Part 6 passage with exactly 4 blanks and 4 questions.
Make sure the content has around 150 words.
Use double underscore with blank number format for blanks, like this: __ (1) __

Use the following JSON format:

{
  "part": "Part6",
  "title": "(Optional)",
  "content_with_blanks": "The company __ (1) __ new policies to improve efficiency...",
  "word_count": 150,
  "reading_level": "Intermediate",
  "topic": "Business Policy",
  "source": "Generated by LLM",
  "questions": [
    {
      "blank_number": 1,
      "question_text": "What best fits blank (1)?",
      "options": { "A": "announce", "B": "announced", "C": "announces", "D": "announcement" },
      "correct_answer": "B",
      "explanation": "Past tense fits the sentence."
    }
  ]
}
Only return the JSON.
"""
    for retry_index in range(max_retries):
        response = ollama.chat(model=DEFAULT_MODEL, messages=[{"role": "user", "content": prompt}])
        content = response['message']['content']

        if debug:
            print(f"🔹 Part 6 第{retry_index+1}次嘗試生成內容：\n", content)

        try:
            data = json.loads(content)
            if len(data.get("questions", [])) == 4:
                saved = save_toeic_data(data)
                if saved:
                    return True
        except json.JSONDecodeError as e:
            print("❌ JSON decode failed:", e)
    return False

# ---------- Part 7 ----------
def get_dynamic_prompt_part7():
    random_topic = random.choice([
        "Meeting Reminder", "Travel Policy Update", "New Product Launch",
        "Employee Memo", "Hiring Announcement", "Training Invitation"
    ])
    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')

    return f"""
You are a professional TOEIC test generator.

Your task is to create exactly ONE TOEIC Reading Comprehension (Part 7) passage with exactly 5 multiple choice questions.

Please follow these rules carefully:
- DO NOT include any explanation, comments, or notes.
- DO NOT use single quotes. Use double quotes for all JSON keys and strings.
- Return ONLY valid JSON, no Markdown, no backticks, no text outside the JSON.
- Questions must follow the content of the passage.
- Each question must include "question_text", "options", "correct_answer", and "explanation".
- Options must include keys "A", "B", "C", and "D".

Here is the JSON format you must return (replace placeholders with actual content):

{{
  "part": "Part7",
  "title": "{random_topic}",
  "content_with_blanks": "Your passage goes here. Aim for around 200 words. The passage should be realistic, related to the topic, and business appropriate.",
  "word_count": 200,
  "reading_level": "Upper Intermediate",
  "topic": "Business Announcement",
  "source": "Generated by LLM",
  "questions": [
    {{
      "question_text": "What is the main purpose of the announcement?",
      "options": {{
        "A": "Option A text",
        "B": "Option B text",
        "C": "Option C text",
        "D": "Option D text"
      }},
      "correct_answer": "C",
      "explanation": "Brief explanation of why C is correct."
    }}
    // Include exactly 5 questions like this, comma separated
  ]
}}

ONLY return the JSON structure. DO NOT add anything else.
"""
def generate_part7_questions(debug: bool = False, max_retries: int = 3) -> bool:
    for retry_index in range(max_retries):
        prompt = get_dynamic_prompt_part7()
        response = ollama.chat(model=DEFAULT_MODEL, messages=[{"role": "user", "content": prompt}])
        content = response['message']['content']

        if debug:
            print(f"🔹 Part 7 第{retry_index+1}次嘗試生成內容：\n", content)

        try:
            data = json.loads(content)
            if len(data.get("questions", [])) == 5:
                saved = save_toeic_data(data)
                if saved:
                    return True
        except json.JSONDecodeError as e:
            print("❌ JSON decode failed:", e)
    return False
